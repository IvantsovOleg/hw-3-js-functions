<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>hw-3-js-functions</title>
</head>
<body>
<script>

    // 1) Write a function splitAndMerge
    function splitAndMerge (string, separator = ' ') {
        let result = '';
        let arrayWords = string.split(' ');
        for (let word of arrayWords) {
            for (let letter of word) {
                result += (letter + separator);
            }
        }
        return result.slice(0, result.length - (separator.length));
    }

    console.log(splitAndMerge('My name is John'));

    // 2. Write a function convert

    let employee = {
        name: 'Jeremy',
        age: 24,
        role: 'Software Engineer'
    };

    // option # 1

    function convert(object) {
        let result = [];
        for(let key in object) {
            result.push([key, object[key]]);
        }
        return result;
    }

    console.log(convert(employee));

    // option # 2

    let result = Object.keys(employee).map(key => {
        return [key, employee[key]];
    });

    console.log(result);

    // 3) Complete the method/function so that it converts dash/underscore
    // delimited words into camel casing. The first word within the output
    // should be capitalized only if the original word was capitalized.

    function toCamelCase(string) {
        let result = '';
        let arrayWords = string.split(/[-_]/g);
        arrayWords.forEach((value, index) => {
            if (!index) {
                result += value.toLowerCase();
            } else {
                result += value[0].toUpperCase() + value.slice(1).toLowerCase();
            }
        });
        return result;
    }

    console.log(toCamelCase('tHe-SteaLth-waRrrioR'));
    console.log(toCamelCase('tHe_SteaLth_waRrrioR'));

    // 4) Write a function that takes a sentence (string)
    // and reverses each word in the sentence.

    function stringReverse(string, devider = ' ') {
        let result = [];
        string.split(devider).forEach(value => {
           if (value.length >= 2) {
               let reverseValue = '';
               for (let i = (value.length - 1); i >=0; i--) {
                   reverseValue += value[i];
               }
               result.push(reverseValue);
           } else if (value === '') {
               result.push(' ');
           } else {
               result.push(value);
           }
        });
        return result.join(devider);
    }

    console.log(stringReverse(' A fun little challenge! '));

    // 5) Write a function stringExpansion
    // I'AM NOT RESOLVE THIS TASK YET - BUT I WILL

    // function stringExpansion(string) {
    //     let newArr = [];
    //     for (let i = 0; i < string.length; i++) {
    //         if(isNaN(Number(string[i])))
        // }
        // return newArr;
    // }

    // console.log(stringExpansion('3a45B2d8a'));
    // stringExpansion('3a45B2d8a');

    // 6) Write largest and smallest functions that returns the largest and smallest number passed like a argument.

    function largest(...arg) {
        let max = 0;
        arg.forEach(value => {
            if (value >= max) max = value;
        });
        return max;
    }

    function smallest(...arg) {
        let min = 0;
        arg.forEach(value =>  {
            if (value <= min) min = value;
        });
        return min;
    }

    console.log(largest(2, 0.1, -5, 100, 3));
    console.log(smallest(2, 0.1, -5, 100, 3));

    // 7) Write function transform that will transform array of numbers to array of functions that will return value from a base array.

    function transform(arr) {
        let result = [];
        for (let i = 0; i < arr.length; i++) {
            result.push(function (value) {
                return function () {
                    return value;
                }
            }(arr[i]));
        }
        return result;
    }

    const baseArray = [10, 20, 30, 40, 50];
    const newArray = transform(baseArray);
    console.log(newArray[3]());
    console.log(newArray[4]());

    // 8) Write function sum. Function expects arbitrary number of digit arguments and returns compound value of them.

    function sum(...arg) {
        if(arg.length === 0){
            return 0;
        }
        function recursSum (array, key = 0) {
            if(key === array.length - 1) {
                return array[key];
            }
            return array[key] + recursSum(array, key + 1);
        }
        return recursSum(arg);
    }

    console.log(sum(1,3,5,7));

    // 9) Write function countDown. Function expects number and logs values one by one till zero with one second delay.

    function countDown (number) {
        let counter = Number(number) || 0; // if number is string
        if (counter < 0) counter = 0; // if number is less than zero
        console.log(counter);
        let timer = setInterval(() => {
            if (counter <= 0) {
                clearInterval(timer);
                return;
            }
            console.log(counter - 1);
            counter--;
        }, 1000);
    }

    countDown(8);

    // 10) Write a polyfill for a .bind() function and save it in Function.prototype.myBind().
    // myBind() should work in an exact same way as the usual bind() - take context
    // as a first parameter and the list of arguments separated by comma.

    Function.prototype.myBind = function (context) {
        let myfunction = this;
        return function(number) {
            return myfunction.call(context, number);
        }
    }

    function addPropToNumber(number) {
        return this.prop + number
    }

    let bound = addPropToNumber.myBind({ prop: 9 });
    console.log(bound(2));


</script>
</body>
</html>
